---
title: "Import Survey"
author: "Evaluator toolkit (https://github.com/davidski/evaluator)"
params:
  write_files:
    label: "Write results to disk"
    value: TRUE
    choices: [TRUE, FALSE]
output:
  html_document: default
  pdf_document: default
  html_notebook: default
  word_document: default
---

# Summary

Import scoring survey spreadsheet and generate the individual data files 
needed for future simulation.

If you wish to commit the results of this process to disk, set the `write_files` 
parameter when knitting to `TRUE`. A value of `FALSE` will run the process, 
but not write to storage.

```{r validate_flag}
write_files <- params$write_files
message("Write files: ", write_files)
```
## File Format

The survey spreadsheet must have one tab for each domain ID defined in the 
`data/domains.csv` file. Each domain tab must have a capabilities table 
beginning at row 2 (with row 1 ignored as the table title), followed 
by one blank row, the Threats table tile, then the threats table itself. All 
other sheets (instructions, reference, etc.) are ignored.

```{r setup, include=FALSE}
if ("pacman" %in% installed.packages()) {
  pacman::p_load(readxl, tidyverse, magrittr, pander)
  if (!pacman::p_isinstalled(stringi)) {
    pacman::p_install(stringi)
  }
} else {
  library(readxl)
  library(tidyverse)
  library(magrittr)
  library(pander)
  library(stringi)
}

panderOptions('table.split.table', Inf) # allow pander to make pages wide
panderOptions('table.alignment.default', function(df)
    ifelse(sapply(df, is.numeric), 'right', 'left'))
panderOptions('big.mark', ",")
```

# Process

Set the name of the survey spreadsheet (located in the `survey` subdirectory) 
in the following code block:

```{r survey_sheet}
survey_file_name <- if (file.exists(".evaluator")) {
  yaml::yaml.load_file(".evaluator")$survey_file
} else {
  survey_file_name <- file.path('survey/HITRUST Survey Document.xlsx')
}
message("Target file is ", survey_file_name)
```

## Read in Survey Spreadsheet

Using the `domains.csv` file, pull in the individual domains from the 
survey spreadsheet. Expecting one matching sheet per domain ID.

```{r read_spreadsheet, message = FALSE}
domains <- read_csv("data/domains.csv", quote = "\"") # program domains
raw_domains <- domains %>% 
  mutate(raw_data = map(domain_id, ~ read_excel(
    paste(survey_file_name, sep="/"), skip=1, sheet=.)))
raw_domains
```

## Parse Capabilities and Threat Tables

Set up a helper function `split_sheet` that takes the contents 
of a given sheet and returns either the capabilities or the threats (scenario) 
information.

```{r define_splitter}
split_sheet <- function(dat, table_type = "capabilities") {
  # remote all NA rows
  dat <- dat[!!rowSums(!is.na(dat) != 0 ), ]
  # find the row where the threats table starts
  split_point <- which(dat$Name == "Threats")
  #message("Type is ", table_type)
  
  if (table_type == "capabilities") {
    # generate capabilities data
    capabilities_data <- dat[1:(split_point - 1), ]
    names(capabilities_data) <-
      make.names(
        names = names(capabilities_data),
        unique = TRUE,
        allow_ = TRUE
      )
    capabilities_data %<>% select(matches("^[^X]"))
    capabilities_data
  } else {
    # generate threats_data
    threats_data <- dat[(split_point + 2):nrow(dat), ]
    names(threats_data) <-
      dat[(split_point + 1), ] %>% t %>% as.matrix() %>% as.vector()
    threats_data
  }
  
}
```

```{r debugging, eval = FALSE, include = FALSE}
# The following block is not executed. This is debugging code for development
dat <- raw_domains[[2, "raw_data"]]
which(raw_domains[[2, "raw_data"]]$Name == "Threats")
split_point = 6
dat[(split_point + 2):nrow(dat),]
dat[(split_point + 1), ] %>% t %>% as.matrix() %>% as.vector()
#which
split_sheet(raw_domains[[2, "raw_data"]], table_type = "threats")
```

Apply the helper function to the raw Excel import.

```{r walk_the_frame}
raw_domains %>% 
  mutate(capabilities = map(raw_data, split_sheet), 
         threats = map(raw_data, ~ split_sheet(dat = .x, table_type = "threats"))) %>% 
  select(-raw_data) -> dat
dat
```

Using the `tidyr::unnest` function, expand each of the tables with the 
associated domain information, mapping the column names to the expected final 
output format. View the data as a final visual check prior to writting to file.

```{r create_data_frames}
capabilities <- unnest(dat, capabilities) %>% 
  select(id = CapabilityID, domain_id, capability = Name, 
         diff = DIFF) %>% 
  mutate(id = as.integer(id)) %>% arrange(id)
capabilities

scenarios <- unnest(dat, threats) %>% 
  select(scenario_id = ScenarioID, scenario = Scenario, tcomm = TComm, tef = TEF, 
         tc = TC, lm = LM, domain_id, controls = Capabilities) %>% 
  mutate(scenario_id = as.integer(scenario_id)) %>% arrange(scenario_id)
# add the number of controls applicable to each scenario as a validation step
scenarios %<>% rowwise %>% 
  mutate(control_count = length(stringi::stri_split_fixed(controls, ", ", 
                                                          simplify = TRUE))) %>% 
  ungroup

scenarios
```

## Data Validation

Perform some minimal data validation between the capabilites and scenarios 
tables.

```{r valdiate_spreadsheet}
# Check that scenario IDs have no gaps
scenario_gaps <- setdiff(seq(range(scenarios$scenario_id)[1], 
                              range(scenarios$scenario_id)[2]), 
                          scenarios$scenario_id)
if (length(scenario_gaps) != 0) stop(paste("Scenario gaps found:", 
                                           scenario_gaps, collapse = "\n"))

# Verify there are no duplicate scenarios
scenarios %>% group_by(scenario_id) %>% tally %>% 
  filter(n > 1) %>% left_join(scenarios) %>% rename(times_duplicated = n) -> 
  duplicate_scenarios
if (nrow(duplicate_scenarios) != 0) stop(paste("Duplicate scenarios found:", 
                                           duplicate_scenarios$scenario_id, 
                                           collapse = "\n"))

# Check that control IDs have no gaps
capability_gaps <- setdiff(seq(range(capabilities$id)[1], 
                               range(capabilities$id)[2]), 
                           capabilities$id)
if (length(capability_gaps) != 0) stop(paste("Capability gaps found:", 
                                           capability_gaps, collapse = "\n"))

# Are all the referenced capabilities from the scenarios defined?
missing_capabilities <- scenarios %>% 
  separate_rows(controls, sep = ",", convert = TRUE) %>% 
  anti_join(capabilities, by = c("controls" = "id"))
if (nrow(missing_capabilities) != 0) stop(paste("Scenarios with undefined controls:", 
                                           missing_capabilities$scenario_id, 
                                           collapse = "\n"))

# Verify there are no duplicate controls
capabilities %>% group_by(id) %>% tally %>% 
  filter(n > 1) %>% left_join(capabilities, by = c("id" = "id")) %>% 
  rename(times_duplicated = n) -> duplicate_capabilities
if (nrow(duplicate_capabilities) != 0) stop(paste("Duplicate capabilities found:", 
                                           duplicate_capabilities$id, 
                                           collapse = "\n"))
```

### Cross-Validate with Qualitative Mappings Table

Cross validate the qualitative terms used in the spreadsheet with the 
mappings data file, `qualitative_mappings.csv`.

```{r check_qualitative_mappings}
mappings <- read_csv("data/qualitative_mappings.csv")
stop_message <- NULL

# TEF
if (!all((tolower(distinct(scenarios, tef)$tef) %in% filter(mappings, type=="tef")$label))) {
  stop_message <- paste(stop_message, 
                        "There are TEF values in the scenarios spreadsheet which are not in qualitative_mappings.csv", sep="\n") 
}
# TC
if (!all((tolower(distinct(scenarios, tc)$tc) %in% filter(mappings, type=="tc")$label))) {
  stop_message <- paste(stop_message, 
                        "There are TC values in the scenarios spreadsheet not found in qualitative_mappings.csv", sep="\n") 
}
# DIFF
if (!all((tolower(distinct(capabilities, diff)$diff) %in% tolower(filter(mappings, type=="diff")$label)))) {
  stop_message <- paste(stop_message, 
                        "There are DIFF values in the scenarios spreadsheet not found in qualitative_mappings.csv", sep="\n") 
}
# LM
if (!all((tolower(distinct(scenarios, lm)$lm) %in% filter(mappings, type=="lm")$label))) {
  stop_message <- paste(stop_message, 
                        "There are LM values in the scenarios spreadsheet not found in qualitative_mappings.csv", sep="\n") 
}

if (!is.null(stop_message)) {
  stop(stop_message)
}
```

## Output to Storage

Write out the objects in CSV format.

```{r write_files}
if (exists("write_files") && write_files)  {
  write_csv(capabilities, path = "./data/capabilities.csv")
  scenarios %>% select(-control_count) %>% write_csv(path = "./data/scenarios.csv")

  file.info(c("data/capabilities.csv", "data/scenarios.csv")) %>% 
    rownames_to_column("filename") %>% as_data_frame %>% pander
} else {
  message("Write_files not set to TRUE. Not writing to disk.")
}
```
